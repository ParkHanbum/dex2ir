#include <iostream>

#include "base/allocator.h"
#include "base/mutex.h"
#include "base/unix_file/fd_file.h"
#include "dex_file.h"
#include "dex_instruction.h"
#include "gc_root.h"
#include "gc/collector/gc_type.h"
#include "gc/collector_type.h"
#include "gc/space/space.h"
#include "gc/heap.h"
#include "indirect_reference_table.h"
#include "instruction_set.h"
#include "invoke_type.h"
#include "jdwp/jdwp.h"
#include "jdwp/jdwp_constants.h"
#include "lock_word.h"
#include "mirror/class.h"
#include "oat.h"
#include "quick/inline_method_analyser.h"
#include "thread.h"
#include "thread_state.h"
#include "verifier/method_verifier.h"

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace unix_file {
std::ostream& operator<<(std::ostream& os, const FdFile::GuardState& rhs) {
  switch (rhs) {
    case FdFile::GuardState::kBase: os << "Base"; break;
    case FdFile::GuardState::kFlushed: os << "Flushed"; break;
    case FdFile::GuardState::kClosed: os << "Closed"; break;
    case FdFile::GuardState::kNoCheck: os << "NoCheck"; break;
  }
  return os;
}
}  // namespace unix_file

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
std::ostream& operator<<(std::ostream& os, const CollectorType& rhs) {
  switch (rhs) {
    case kCollectorTypeNone: os << "CollectorTypeNone"; break;
    case kCollectorTypeMS: os << "CollectorTypeMS"; break;
    case kCollectorTypeCMS: os << "CollectorTypeCMS"; break;
    case kCollectorTypeSS: os << "CollectorTypeSS"; break;
    case kCollectorTypeGSS: os << "CollectorTypeGSS"; break;
    case kCollectorTypeMC: os << "CollectorTypeMC"; break;
    case kCollectorTypeHeapTrim: os << "CollectorTypeHeapTrim"; break;
    case kCollectorTypeCC: os << "CollectorTypeCC"; break;
    case kCollectorTypeHomogeneousSpaceCompact: os << "CollectorTypeHomogeneousSpaceCompact"; break;
    default: os << "CollectorType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpTag& rhs) {
  switch (rhs) {
    case JT_ARRAY: os << "JT_ARRAY"; break;
    case JT_BYTE: os << "JT_BYTE"; break;
    case JT_CHAR: os << "JT_CHAR"; break;
    case JT_OBJECT: os << "JT_OBJECT"; break;
    case JT_FLOAT: os << "JT_FLOAT"; break;
    case JT_DOUBLE: os << "JT_DOUBLE"; break;
    case JT_INT: os << "JT_INT"; break;
    case JT_LONG: os << "JT_LONG"; break;
    case JT_SHORT: os << "JT_SHORT"; break;
    case JT_VOID: os << "JT_VOID"; break;
    case JT_BOOLEAN: os << "JT_BOOLEAN"; break;
    case JT_STRING: os << "JT_STRING"; break;
    case JT_THREAD: os << "JT_THREAD"; break;
    case JT_THREAD_GROUP: os << "JT_THREAD_GROUP"; break;
    case JT_CLASS_LOADER: os << "JT_CLASS_LOADER"; break;
    case JT_CLASS_OBJECT: os << "JT_CLASS_OBJECT"; break;
    default: os << "JdwpTag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const LockWord::LockState& rhs) {
  switch (rhs) {
    case LockWord::kUnlocked: os << "Unlocked"; break;
    case LockWord::kThinLocked: os << "ThinLocked"; break;
    case LockWord::kFatLocked: os << "FatLocked"; break;
    case LockWord::kHashCode: os << "HashCode"; break;
    case LockWord::kForwardingAddress: os << "ForwardingAddress"; break;
    default: os << "LockWord::LockState[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpStepDepth& rhs) {
  switch (rhs) {
    case SD_INTO: os << "SD_INTO"; break;
    case SD_OVER: os << "SD_OVER"; break;
    case SD_OUT: os << "SD_OUT"; break;
    default: os << "JdwpStepDepth[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const Instruction::Flags& rhs) {
  switch (rhs) {
    case Instruction::kBranch: os << "Branch"; break;
    case Instruction::kContinue: os << "Continue"; break;
    case Instruction::kSwitch: os << "Switch"; break;
    case Instruction::kThrow: os << "Throw"; break;
    case Instruction::kReturn: os << "Return"; break;
    case Instruction::kInvoke: os << "Invoke"; break;
    case Instruction::kUnconditional: os << "Unconditional"; break;
    case Instruction::kAdd: os << "Add"; break;
    case Instruction::kSubtract: os << "Subtract"; break;
    case Instruction::kMultiply: os << "Multiply"; break;
    case Instruction::kDivide: os << "Divide"; break;
    case Instruction::kRemainder: os << "Remainder"; break;
    case Instruction::kAnd: os << "And"; break;
    case Instruction::kOr: os << "Or"; break;
    case Instruction::kXor: os << "Xor"; break;
    case Instruction::kShl: os << "Shl"; break;
    case Instruction::kShr: os << "Shr"; break;
    case Instruction::kUshr: os << "Ushr"; break;
    case Instruction::kCast: os << "Cast"; break;
    case Instruction::kStore: os << "Store"; break;
    case Instruction::kLoad: os << "Load"; break;
    case Instruction::kClobber: os << "Clobber"; break;
    case Instruction::kRegCFieldOrConstant: os << "RegCFieldOrConstant"; break;
    case Instruction::kRegBFieldOrConstant: os << "RegBFieldOrConstant"; break;
    default: os << "Instruction::Flags[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const InlineMethodOpcode& rhs) {
  switch (rhs) {
    case kIntrinsicDoubleCvt: os << "IntrinsicDoubleCvt"; break;
    case kIntrinsicFloatCvt: os << "IntrinsicFloatCvt"; break;
    case kIntrinsicReverseBits: os << "IntrinsicReverseBits"; break;
    case kIntrinsicReverseBytes: os << "IntrinsicReverseBytes"; break;
    case kIntrinsicAbsInt: os << "IntrinsicAbsInt"; break;
    case kIntrinsicAbsLong: os << "IntrinsicAbsLong"; break;
    case kIntrinsicAbsFloat: os << "IntrinsicAbsFloat"; break;
    case kIntrinsicAbsDouble: os << "IntrinsicAbsDouble"; break;
    case kIntrinsicMinMaxInt: os << "IntrinsicMinMaxInt"; break;
    case kIntrinsicMinMaxLong: os << "IntrinsicMinMaxLong"; break;
    case kIntrinsicMinMaxFloat: os << "IntrinsicMinMaxFloat"; break;
    case kIntrinsicMinMaxDouble: os << "IntrinsicMinMaxDouble"; break;
    case kIntrinsicSqrt: os << "IntrinsicSqrt"; break;
    case kIntrinsicCeil: os << "IntrinsicCeil"; break;
    case kIntrinsicFloor: os << "IntrinsicFloor"; break;
    case kIntrinsicRint: os << "IntrinsicRint"; break;
    case kIntrinsicRoundFloat: os << "IntrinsicRoundFloat"; break;
    case kIntrinsicRoundDouble: os << "IntrinsicRoundDouble"; break;
    case kIntrinsicReferenceGetReferent: os << "IntrinsicReferenceGetReferent"; break;
    case kIntrinsicCharAt: os << "IntrinsicCharAt"; break;
    case kIntrinsicCompareTo: os << "IntrinsicCompareTo"; break;
    case kIntrinsicIsEmptyOrLength: os << "IntrinsicIsEmptyOrLength"; break;
    case kIntrinsicIndexOf: os << "IntrinsicIndexOf"; break;
    case kIntrinsicCurrentThread: os << "IntrinsicCurrentThread"; break;
    case kIntrinsicPeek: os << "IntrinsicPeek"; break;
    case kIntrinsicPoke: os << "IntrinsicPoke"; break;
    case kIntrinsicCas: os << "IntrinsicCas"; break;
    case kIntrinsicUnsafeGet: os << "IntrinsicUnsafeGet"; break;
    case kIntrinsicUnsafePut: os << "IntrinsicUnsafePut"; break;
    case kIntrinsicSystemArrayCopyCharArray: os << "IntrinsicSystemArrayCopyCharArray"; break;
    case kInlineOpNop: os << "InlineOpNop"; break;
    case kInlineOpReturnArg: os << "InlineOpReturnArg"; break;
    case kInlineOpNonWideConst: os << "InlineOpNonWideConst"; break;
    case kInlineOpIGet: os << "InlineOpIGet"; break;
    case kInlineOpIPut: os << "InlineOpIPut"; break;
    default: os << "InlineMethodOpcode[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
std::ostream& operator<<(std::ostream& os, const HomogeneousSpaceCompactResult& rhs) {
  switch (rhs) {
    case kSuccess: os << "Success"; break;
    case kErrorReject: os << "ErrorReject"; break;
    case kErrorVMShuttingDown: os << "ErrorVMShuttingDown"; break;
    default: os << "HomogeneousSpaceCompactResult[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace verifier {
std::ostream& operator<<(std::ostream& os, const VerifyErrorRefType& rhs) {
  switch (rhs) {
    case VERIFY_ERROR_REF_CLASS: os << "VERIFY_ERROR_REF_CLASS"; break;
    case VERIFY_ERROR_REF_FIELD: os << "VERIFY_ERROR_REF_FIELD"; break;
    case VERIFY_ERROR_REF_METHOD: os << "VERIFY_ERROR_REF_METHOD"; break;
    default: os << "VerifyErrorRefType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace verifier
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const IndirectRefKind& rhs) {
  switch (rhs) {
    case kHandleScopeOrInvalid: os << "stack indirect reference table or invalid reference"; break;
    case kLocal: os << "local reference"; break;
    case kGlobal: os << "global reference"; break;
    case kWeakGlobal: os << "weak global reference"; break;
    default: os << "IndirectRefKind[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpThreadStatus& rhs) {
  switch (rhs) {
    case TS_ZOMBIE: os << "TS_ZOMBIE"; break;
    case TS_RUNNING: os << "TS_RUNNING"; break;
    case TS_SLEEPING: os << "TS_SLEEPING"; break;
    case TS_MONITOR: os << "TS_MONITOR"; break;
    case TS_WAIT: os << "TS_WAIT"; break;
    default: os << "JdwpThreadStatus[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
namespace space {
std::ostream& operator<<(std::ostream& os, const GcRetentionPolicy& rhs) {
  switch (rhs) {
    case kGcRetentionPolicyNeverCollect: os << "GcRetentionPolicyNeverCollect"; break;
    case kGcRetentionPolicyAlwaysCollect: os << "GcRetentionPolicyAlwaysCollect"; break;
    case kGcRetentionPolicyFullCollect: os << "GcRetentionPolicyFullCollect"; break;
    default: os << "GcRetentionPolicy[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace space
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const ThreadState& rhs) {
  switch (rhs) {
    case kTerminated: os << "Terminated"; break;
    case kRunnable: os << "Runnable"; break;
    case kTimedWaiting: os << "TimedWaiting"; break;
    case kSleeping: os << "Sleeping"; break;
    case kBlocked: os << "Blocked"; break;
    case kWaiting: os << "Waiting"; break;
    case kWaitingForGcToComplete: os << "WaitingForGcToComplete"; break;
    case kWaitingForCheckPointsToRun: os << "WaitingForCheckPointsToRun"; break;
    case kWaitingPerformingGc: os << "WaitingPerformingGc"; break;
    case kWaitingForDebuggerSend: os << "WaitingForDebuggerSend"; break;
    case kWaitingForDebuggerToAttach: os << "WaitingForDebuggerToAttach"; break;
    case kWaitingInMainDebuggerLoop: os << "WaitingInMainDebuggerLoop"; break;
    case kWaitingForDebuggerSuspension: os << "WaitingForDebuggerSuspension"; break;
    case kWaitingForJniOnLoad: os << "WaitingForJniOnLoad"; break;
    case kWaitingForSignalCatcherOutput: os << "WaitingForSignalCatcherOutput"; break;
    case kWaitingInMainSignalCatcherLoop: os << "WaitingInMainSignalCatcherLoop"; break;
    case kWaitingForDeoptimization: os << "WaitingForDeoptimization"; break;
    case kWaitingForMethodTracingStart: os << "WaitingForMethodTracingStart"; break;
    case kStarting: os << "Starting"; break;
    case kNative: os << "Native"; break;
    case kSuspended: os << "Suspended"; break;
    default: os << "ThreadState[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const IntrinsicFlags& rhs) {
  switch (rhs) {
    case kIntrinsicFlagNone: os << "IntrinsicFlagNone"; break;
    case kIntrinsicFlagMin: os << "IntrinsicFlagMin"; break;
    case kIntrinsicFlagIsVolatile: os << "IntrinsicFlagIsVolatile"; break;
    case kIntrinsicFlagIsObject: os << "IntrinsicFlagIsObject"; break;
    case kIntrinsicFlagIsOrdered: os << "IntrinsicFlagIsOrdered"; break;
    default: os << "IntrinsicFlags[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpSuspendPolicy& rhs) {
  switch (rhs) {
    case SP_NONE: os << "SP_NONE"; break;
    case SP_EVENT_THREAD: os << "SP_EVENT_THREAD"; break;
    case SP_ALL: os << "SP_ALL"; break;
    default: os << "JdwpSuspendPolicy[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const InstructionSet& rhs) {
  switch (rhs) {
    case kNone: os << "None"; break;
    case kArm: os << "Arm"; break;
    case kArm64: os << "Arm64"; break;
    case kThumb2: os << "Thumb2"; break;
    case kX86: os << "X86"; break;
    case kX86_64: os << "X86_64"; break;
    case kMips: os << "Mips"; break;
    case kMips64: os << "Mips64"; break;
    default: os << "InstructionSet[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpTransportType& rhs) {
  switch (rhs) {
    case kJdwpTransportUnknown: os << "JdwpTransportUnknown"; break;
    case kJdwpTransportSocket: os << "JdwpTransportSocket"; break;
    case kJdwpTransportAndroidAdb: os << "JdwpTransportAndroidAdb"; break;
    default: os << "JdwpTransportType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
std::ostream& operator<<(std::ostream& os, const ProcessState& rhs) {
  switch (rhs) {
    case kProcessStateJankPerceptible: os << "ProcessStateJankPerceptible"; break;
    case kProcessStateJankImperceptible: os << "ProcessStateJankImperceptible"; break;
    default: os << "ProcessState[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const InlineMethodFlags& rhs) {
  switch (rhs) {
    case kNoInlineMethodFlags: os << "NoInlineMethodFlags"; break;
    case kInlineIntrinsic: os << "InlineIntrinsic"; break;
    case kInlineSpecial: os << "InlineSpecial"; break;
    default: os << "InlineMethodFlags[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpSuspendStatus& rhs) {
  switch (rhs) {
    case SUSPEND_STATUS_NOT_SUSPENDED: os << "SUSPEND_STATUS_NOT_SUSPENDED"; break;
    case SUSPEND_STATUS_SUSPENDED: os << "SUSPEND_STATUS_SUSPENDED"; break;
    default: os << "JdwpSuspendStatus[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const AllocatorTag& rhs) {
  switch (rhs) {
    case kAllocatorTagHeap: os << "AllocatorTagHeap"; break;
    case kAllocatorTagMonitorList: os << "AllocatorTagMonitorList"; break;
    case kAllocatorTagClassTable: os << "AllocatorTagClassTable"; break;
    case kAllocatorTagInternTable: os << "AllocatorTagInternTable"; break;
    case kAllocatorTagMaps: os << "AllocatorTagMaps"; break;
    case kAllocatorTagLOS: os << "AllocatorTagLOS"; break;
    case kAllocatorTagSafeMap: os << "AllocatorTagSafeMap"; break;
    case kAllocatorTagLOSMaps: os << "AllocatorTagLOSMaps"; break;
    case kAllocatorTagReferenceTable: os << "AllocatorTagReferenceTable"; break;
    case kAllocatorTagHeapBitmap: os << "AllocatorTagHeapBitmap"; break;
    case kAllocatorTagHeapBitmapLOS: os << "AllocatorTagHeapBitmapLOS"; break;
    case kAllocatorTagMonitorPool: os << "AllocatorTagMonitorPool"; break;
    case kAllocatorTagLOSFreeList: os << "AllocatorTagLOSFreeList"; break;
    case kAllocatorTagVerifier: os << "AllocatorTagVerifier"; break;
    case kAllocatorTagRememberedSet: os << "AllocatorTagRememberedSet"; break;
    case kAllocatorTagModUnionCardSet: os << "AllocatorTagModUnionCardSet"; break;
    case kAllocatorTagModUnionReferenceArray: os << "AllocatorTagModUnionReferenceArray"; break;
    case kAllocatorTagJNILibrarires: os << "AllocatorTagJNILibrarires"; break;
    case kAllocatorTagCompileTimeClassPath: os << "AllocatorTagCompileTimeClassPath"; break;
    case kAllocatorTagOatFile: os << "AllocatorTagOatFile"; break;
    case kAllocatorTagDexFileVerifier: os << "AllocatorTagDexFileVerifier"; break;
    case kAllocatorTagCount: os << "AllocatorTagCount"; break;
    default: os << "AllocatorTag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const InstructionFeatures& rhs) {
  switch (rhs) {
    case kHwDiv: os << "HwDiv"; break;
    case kHwLpae: os << "HwLpae"; break;
    default: os << "InstructionFeatures[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
namespace collector {
std::ostream& operator<<(std::ostream& os, const GcType& rhs) {
  switch (rhs) {
    case kGcTypeNone: os << "GcTypeNone"; break;
    case kGcTypeSticky: os << "GcTypeSticky"; break;
    case kGcTypePartial: os << "GcTypePartial"; break;
    case kGcTypeFull: os << "GcTypeFull"; break;
    case kGcTypeMax: os << "GcTypeMax"; break;
    default: os << "GcType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace collector
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const LockLevel& rhs) {
  switch (rhs) {
    case kLoggingLock: os << "LoggingLock"; break;
    case kMemMapsLock: os << "MemMapsLock"; break;
    case kSwapMutexesLock: os << "SwapMutexesLock"; break;
    case kUnexpectedSignalLock: os << "UnexpectedSignalLock"; break;
    case kThreadSuspendCountLock: os << "ThreadSuspendCountLock"; break;
    case kAbortLock: os << "AbortLock"; break;
    case kJdwpSocketLock: os << "JdwpSocketLock"; break;
    case kReferenceQueueSoftReferencesLock: os << "ReferenceQueueSoftReferencesLock"; break;
    case kReferenceQueuePhantomReferencesLock: os << "ReferenceQueuePhantomReferencesLock"; break;
    case kReferenceQueueFinalizerReferencesLock: os << "ReferenceQueueFinalizerReferencesLock"; break;
    case kReferenceQueueWeakReferencesLock: os << "ReferenceQueueWeakReferencesLock"; break;
    case kReferenceQueueClearedReferencesLock: os << "ReferenceQueueClearedReferencesLock"; break;
    case kReferenceProcessorLock: os << "ReferenceProcessorLock"; break;
    case kRosAllocGlobalLock: os << "RosAllocGlobalLock"; break;
    case kRosAllocBracketLock: os << "RosAllocBracketLock"; break;
    case kRosAllocBulkFreeLock: os << "RosAllocBulkFreeLock"; break;
    case kAllocSpaceLock: os << "AllocSpaceLock"; break;
    case kDexFileMethodInlinerLock: os << "DexFileMethodInlinerLock"; break;
    case kDexFileToMethodInlinerMapLock: os << "DexFileToMethodInlinerMapLock"; break;
    case kMarkSweepMarkStackLock: os << "MarkSweepMarkStackLock"; break;
    case kTransactionLogLock: os << "TransactionLogLock"; break;
    case kInternTableLock: os << "InternTableLock"; break;
    case kOatFileSecondaryLookupLock: os << "OatFileSecondaryLookupLock"; break;
    case kDefaultMutexLevel: os << "DefaultMutexLevel"; break;
    case kMarkSweepLargeObjectLock: os << "MarkSweepLargeObjectLock"; break;
    case kPinTableLock: os << "PinTableLock"; break;
    case kLoadLibraryLock: os << "LoadLibraryLock"; break;
    case kJdwpObjectRegistryLock: os << "JdwpObjectRegistryLock"; break;
    case kModifyLdtLock: os << "ModifyLdtLock"; break;
    case kAllocatedThreadIdsLock: os << "AllocatedThreadIdsLock"; break;
    case kMonitorPoolLock: os << "MonitorPoolLock"; break;
    case kClassLinkerClassesLock: os << "ClassLinkerClassesLock"; break;
    case kBreakpointLock: os << "BreakpointLock"; break;
    case kMonitorLock: os << "MonitorLock"; break;
    case kMonitorListLock: os << "MonitorListLock"; break;
    case kThreadListLock: os << "ThreadListLock"; break;
    case kBreakpointInvokeLock: os << "BreakpointInvokeLock"; break;
    case kAllocTrackerLock: os << "AllocTrackerLock"; break;
    case kDeoptimizationLock: os << "DeoptimizationLock"; break;
    case kProfilerLock: os << "ProfilerLock"; break;
    case kJdwpEventListLock: os << "JdwpEventListLock"; break;
    case kJdwpAttachLock: os << "JdwpAttachLock"; break;
    case kJdwpStartLock: os << "JdwpStartLock"; break;
    case kRuntimeShutdownLock: os << "RuntimeShutdownLock"; break;
    case kTraceLock: os << "TraceLock"; break;
    case kHeapBitmapLock: os << "HeapBitmapLock"; break;
    case kMutatorLock: os << "MutatorLock"; break;
    case kInstrumentEntrypointsLock: os << "InstrumentEntrypointsLock"; break;
    case kThreadListSuspendThreadLock: os << "ThreadListSuspendThreadLock"; break;
    case kZygoteCreationLock: os << "ZygoteCreationLock"; break;
    case kLockLevelCount: os << "LockLevelCount"; break;
    default: os << "LockLevel[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpEventKind& rhs) {
  switch (rhs) {
    case EK_SINGLE_STEP: os << "EK_SINGLE_STEP"; break;
    case EK_BREAKPOINT: os << "EK_BREAKPOINT"; break;
    case EK_FRAME_POP: os << "EK_FRAME_POP"; break;
    case EK_EXCEPTION: os << "EK_EXCEPTION"; break;
    case EK_USER_DEFINED: os << "EK_USER_DEFINED"; break;
    case EK_THREAD_START: os << "EK_THREAD_START"; break;
    case EK_THREAD_DEATH: os << "EK_THREAD_DEATH"; break;
    case EK_CLASS_PREPARE: os << "EK_CLASS_PREPARE"; break;
    case EK_CLASS_UNLOAD: os << "EK_CLASS_UNLOAD"; break;
    case EK_CLASS_LOAD: os << "EK_CLASS_LOAD"; break;
    case EK_FIELD_ACCESS: os << "EK_FIELD_ACCESS"; break;
    case EK_FIELD_MODIFICATION: os << "EK_FIELD_MODIFICATION"; break;
    case EK_EXCEPTION_CATCH: os << "EK_EXCEPTION_CATCH"; break;
    case EK_METHOD_ENTRY: os << "EK_METHOD_ENTRY"; break;
    case EK_METHOD_EXIT: os << "EK_METHOD_EXIT"; break;
    case EK_METHOD_EXIT_WITH_RETURN_VALUE: os << "EK_METHOD_EXIT_WITH_RETURN_VALUE"; break;
    case EK_MONITOR_CONTENDED_ENTER: os << "EK_MONITOR_CONTENDED_ENTER"; break;
    case EK_MONITOR_CONTENDED_ENTERED: os << "EK_MONITOR_CONTENDED_ENTERED"; break;
    case EK_MONITOR_WAIT: os << "EK_MONITOR_WAIT"; break;
    case EK_MONITOR_WAITED: os << "EK_MONITOR_WAITED"; break;
    case EK_VM_START: os << "EK_VM_START"; break;
    case EK_VM_DEATH: os << "EK_VM_DEATH"; break;
    case EK_VM_DISCONNECTED: os << "EK_VM_DISCONNECTED"; break;
    default: os << "JdwpEventKind[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const RootType& rhs) {
  switch (rhs) {
    case kRootUnknown: os << "RootUnknown"; break;
    case kRootJNIGlobal: os << "RootJNIGlobal"; break;
    case kRootJNILocal: os << "RootJNILocal"; break;
    case kRootJavaFrame: os << "RootJavaFrame"; break;
    case kRootNativeStack: os << "RootNativeStack"; break;
    case kRootStickyClass: os << "RootStickyClass"; break;
    case kRootThreadBlock: os << "RootThreadBlock"; break;
    case kRootMonitorUsed: os << "RootMonitorUsed"; break;
    case kRootThreadObject: os << "RootThreadObject"; break;
    case kRootInternedString: os << "RootInternedString"; break;
    case kRootDebugger: os << "RootDebugger"; break;
    case kRootVMInternal: os << "RootVMInternal"; break;
    case kRootJNIMonitor: os << "RootJNIMonitor"; break;
    default: os << "RootType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpInvokeOptions& rhs) {
  switch (rhs) {
    case INVOKE_SINGLE_THREADED: os << "INVOKE_SINGLE_THREADED"; break;
    case INVOKE_NONVIRTUAL: os << "INVOKE_NONVIRTUAL"; break;
    default: os << "JdwpInvokeOptions[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const Instruction::VerifyFlag& rhs) {
  switch (rhs) {
    case Instruction::kVerifyNone: os << "VerifyNone"; break;
    case Instruction::kVerifyRegA: os << "VerifyRegA"; break;
    case Instruction::kVerifyRegAWide: os << "VerifyRegAWide"; break;
    case Instruction::kVerifyRegB: os << "VerifyRegB"; break;
    case Instruction::kVerifyRegBField: os << "VerifyRegBField"; break;
    case Instruction::kVerifyRegBMethod: os << "VerifyRegBMethod"; break;
    case Instruction::kVerifyRegBNewInstance: os << "VerifyRegBNewInstance"; break;
    case Instruction::kVerifyRegBString: os << "VerifyRegBString"; break;
    case Instruction::kVerifyRegBType: os << "VerifyRegBType"; break;
    case Instruction::kVerifyRegBWide: os << "VerifyRegBWide"; break;
    case Instruction::kVerifyRegC: os << "VerifyRegC"; break;
    case Instruction::kVerifyRegCField: os << "VerifyRegCField"; break;
    case Instruction::kVerifyRegCNewArray: os << "VerifyRegCNewArray"; break;
    case Instruction::kVerifyRegCType: os << "VerifyRegCType"; break;
    case Instruction::kVerifyRegCWide: os << "VerifyRegCWide"; break;
    case Instruction::kVerifyArrayData: os << "VerifyArrayData"; break;
    case Instruction::kVerifyBranchTarget: os << "VerifyBranchTarget"; break;
    case Instruction::kVerifySwitchTargets: os << "VerifySwitchTargets"; break;
    case Instruction::kVerifyVarArg: os << "VerifyVarArg"; break;
    case Instruction::kVerifyVarArgNonZero: os << "VerifyVarArgNonZero"; break;
    case Instruction::kVerifyVarArgRange: os << "VerifyVarArgRange"; break;
    case Instruction::kVerifyVarArgRangeNonZero: os << "VerifyVarArgRangeNonZero"; break;
    case Instruction::kVerifyRuntimeOnly: os << "VerifyRuntimeOnly"; break;
    case Instruction::kVerifyError: os << "VerifyError"; break;
    default: os << "Instruction::VerifyFlag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace verifier {
std::ostream& operator<<(std::ostream& os, const VerifyError& rhs) {
  switch (rhs) {
    case VERIFY_ERROR_BAD_CLASS_HARD: os << "VERIFY_ERROR_BAD_CLASS_HARD"; break;
    case VERIFY_ERROR_BAD_CLASS_SOFT: os << "VERIFY_ERROR_BAD_CLASS_SOFT"; break;
    case VERIFY_ERROR_NO_CLASS: os << "VERIFY_ERROR_NO_CLASS"; break;
    case VERIFY_ERROR_NO_FIELD: os << "VERIFY_ERROR_NO_FIELD"; break;
    case VERIFY_ERROR_NO_METHOD: os << "VERIFY_ERROR_NO_METHOD"; break;
    case VERIFY_ERROR_ACCESS_CLASS: os << "VERIFY_ERROR_ACCESS_CLASS"; break;
    case VERIFY_ERROR_ACCESS_FIELD: os << "VERIFY_ERROR_ACCESS_FIELD"; break;
    case VERIFY_ERROR_ACCESS_METHOD: os << "VERIFY_ERROR_ACCESS_METHOD"; break;
    case VERIFY_ERROR_CLASS_CHANGE: os << "VERIFY_ERROR_CLASS_CHANGE"; break;
    case VERIFY_ERROR_INSTANTIATION: os << "VERIFY_ERROR_INSTANTIATION"; break;
    default: os << "VerifyError[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace verifier
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpStepSize& rhs) {
  switch (rhs) {
    case SS_MIN: os << "SS_MIN"; break;
    case SS_LINE: os << "SS_LINE"; break;
    default: os << "JdwpStepSize[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace verifier {
std::ostream& operator<<(std::ostream& os, const MethodVerifier::FailureKind& rhs) {
  switch (rhs) {
    case MethodVerifier::kNoFailure: os << "NoFailure"; break;
    case MethodVerifier::kSoftFailure: os << "SoftFailure"; break;
    case MethodVerifier::kHardFailure: os << "HardFailure"; break;
    default: os << "MethodVerifier::FailureKind[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace verifier
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const ThreadPriority& rhs) {
  switch (rhs) {
    case kMinThreadPriority: os << "MinThreadPriority"; break;
    case kNormThreadPriority: os << "NormThreadPriority"; break;
    case kMaxThreadPriority: os << "MaxThreadPriority"; break;
    default: os << "ThreadPriority[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace verifier {
std::ostream& operator<<(std::ostream& os, const MethodType& rhs) {
  switch (rhs) {
    case METHOD_UNKNOWN: os << "METHOD_UNKNOWN"; break;
    case METHOD_DIRECT: os << "METHOD_DIRECT"; break;
    case METHOD_STATIC: os << "METHOD_STATIC"; break;
    case METHOD_VIRTUAL: os << "METHOD_VIRTUAL"; break;
    case METHOD_INTERFACE: os << "METHOD_INTERFACE"; break;
    default: os << "MethodType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace verifier
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpModKind& rhs) {
  switch (rhs) {
    case MK_COUNT: os << "MK_COUNT"; break;
    case MK_CONDITIONAL: os << "MK_CONDITIONAL"; break;
    case MK_THREAD_ONLY: os << "MK_THREAD_ONLY"; break;
    case MK_CLASS_ONLY: os << "MK_CLASS_ONLY"; break;
    case MK_CLASS_MATCH: os << "MK_CLASS_MATCH"; break;
    case MK_CLASS_EXCLUDE: os << "MK_CLASS_EXCLUDE"; break;
    case MK_LOCATION_ONLY: os << "MK_LOCATION_ONLY"; break;
    case MK_EXCEPTION_ONLY: os << "MK_EXCEPTION_ONLY"; break;
    case MK_FIELD_ONLY: os << "MK_FIELD_ONLY"; break;
    case MK_STEP: os << "MK_STEP"; break;
    case MK_INSTANCE_ONLY: os << "MK_INSTANCE_ONLY"; break;
    case MK_SOURCE_NAME_MATCH: os << "MK_SOURCE_NAME_MATCH"; break;
    default: os << "JdwpModKind[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const EncodedStaticFieldValueIterator::ValueType& rhs) {
  switch (rhs) {
    case EncodedStaticFieldValueIterator::kByte: os << "Byte"; break;
    case EncodedStaticFieldValueIterator::kShort: os << "Short"; break;
    case EncodedStaticFieldValueIterator::kChar: os << "Char"; break;
    case EncodedStaticFieldValueIterator::kInt: os << "Int"; break;
    case EncodedStaticFieldValueIterator::kLong: os << "Long"; break;
    case EncodedStaticFieldValueIterator::kFloat: os << "Float"; break;
    case EncodedStaticFieldValueIterator::kDouble: os << "Double"; break;
    case EncodedStaticFieldValueIterator::kString: os << "String"; break;
    case EncodedStaticFieldValueIterator::kType: os << "Type"; break;
    case EncodedStaticFieldValueIterator::kField: os << "Field"; break;
    case EncodedStaticFieldValueIterator::kMethod: os << "Method"; break;
    case EncodedStaticFieldValueIterator::kEnum: os << "Enum"; break;
    case EncodedStaticFieldValueIterator::kArray: os << "Array"; break;
    case EncodedStaticFieldValueIterator::kAnnotation: os << "Annotation"; break;
    case EncodedStaticFieldValueIterator::kNull: os << "Null"; break;
    case EncodedStaticFieldValueIterator::kBoolean: os << "Boolean"; break;
    default: os << "EncodedStaticFieldValueIterator::ValueType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace mirror {
std::ostream& operator<<(std::ostream& os, const Class::Status& rhs) {
  switch (rhs) {
    case Class::kStatusRetired: os << "StatusRetired"; break;
    case Class::kStatusError: os << "StatusError"; break;
    case Class::kStatusNotReady: os << "StatusNotReady"; break;
    case Class::kStatusIdx: os << "StatusIdx"; break;
    case Class::kStatusLoaded: os << "StatusLoaded"; break;
    case Class::kStatusResolving: os << "StatusResolving"; break;
    case Class::kStatusResolved: os << "StatusResolved"; break;
    case Class::kStatusVerifying: os << "StatusVerifying"; break;
    case Class::kStatusRetryVerificationAtRuntime: os << "StatusRetryVerificationAtRuntime"; break;
    case Class::kStatusVerifyingAtRuntime: os << "StatusVerifyingAtRuntime"; break;
    case Class::kStatusVerified: os << "StatusVerified"; break;
    case Class::kStatusInitializing: os << "StatusInitializing"; break;
    case Class::kStatusInitialized: os << "StatusInitialized"; break;
    case Class::kStatusMax: os << "StatusMax"; break;
    default: os << "Class::Status[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace mirror
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const ThreadFlag& rhs) {
  switch (rhs) {
    case kSuspendRequest: os << "SuspendRequest"; break;
    case kCheckpointRequest: os << "CheckpointRequest"; break;
    default: os << "ThreadFlag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace verifier {
std::ostream& operator<<(std::ostream& os, const RegisterTrackingMode& rhs) {
  switch (rhs) {
    case kTrackRegsBranches: os << "TrackRegsBranches"; break;
    case kTrackCompilerInterestPoints: os << "TrackCompilerInterestPoints"; break;
    case kTrackRegsAll: os << "TrackRegsAll"; break;
    default: os << "RegisterTrackingMode[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace verifier
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpError& rhs) {
  switch (rhs) {
    case ERR_NONE: os << "ERR_NONE"; break;
    case ERR_INVALID_THREAD: os << "ERR_INVALID_THREAD"; break;
    case ERR_INVALID_THREAD_GROUP: os << "ERR_INVALID_THREAD_GROUP"; break;
    case ERR_INVALID_PRIORITY: os << "ERR_INVALID_PRIORITY"; break;
    case ERR_THREAD_NOT_SUSPENDED: os << "ERR_THREAD_NOT_SUSPENDED"; break;
    case ERR_THREAD_SUSPENDED: os << "ERR_THREAD_SUSPENDED"; break;
    case ERR_THREAD_NOT_ALIVE: os << "ERR_THREAD_NOT_ALIVE"; break;
    case ERR_INVALID_OBJECT: os << "ERR_INVALID_OBJECT"; break;
    case ERR_INVALID_CLASS: os << "ERR_INVALID_CLASS"; break;
    case ERR_CLASS_NOT_PREPARED: os << "ERR_CLASS_NOT_PREPARED"; break;
    case ERR_INVALID_METHODID: os << "ERR_INVALID_METHODID"; break;
    case ERR_INVALID_LOCATION: os << "ERR_INVALID_LOCATION"; break;
    case ERR_INVALID_FIELDID: os << "ERR_INVALID_FIELDID"; break;
    case ERR_INVALID_FRAMEID: os << "ERR_INVALID_FRAMEID"; break;
    case ERR_NO_MORE_FRAMES: os << "ERR_NO_MORE_FRAMES"; break;
    case ERR_OPAQUE_FRAME: os << "ERR_OPAQUE_FRAME"; break;
    case ERR_NOT_CURRENT_FRAME: os << "ERR_NOT_CURRENT_FRAME"; break;
    case ERR_TYPE_MISMATCH: os << "ERR_TYPE_MISMATCH"; break;
    case ERR_INVALID_SLOT: os << "ERR_INVALID_SLOT"; break;
    case ERR_DUPLICATE: os << "ERR_DUPLICATE"; break;
    case ERR_NOT_FOUND: os << "ERR_NOT_FOUND"; break;
    case ERR_INVALID_MONITOR: os << "ERR_INVALID_MONITOR"; break;
    case ERR_NOT_MONITOR_OWNER: os << "ERR_NOT_MONITOR_OWNER"; break;
    case ERR_INTERRUPT: os << "ERR_INTERRUPT"; break;
    case ERR_INVALID_CLASS_FORMAT: os << "ERR_INVALID_CLASS_FORMAT"; break;
    case ERR_CIRCULAR_CLASS_DEFINITION: os << "ERR_CIRCULAR_CLASS_DEFINITION"; break;
    case ERR_FAILS_VERIFICATION: os << "ERR_FAILS_VERIFICATION"; break;
    case ERR_ADD_METHOD_NOT_IMPLEMENTED: os << "ERR_ADD_METHOD_NOT_IMPLEMENTED"; break;
    case ERR_SCHEMA_CHANGE_NOT_IMPLEMENTED: os << "ERR_SCHEMA_CHANGE_NOT_IMPLEMENTED"; break;
    case ERR_INVALID_TYPESTATE: os << "ERR_INVALID_TYPESTATE"; break;
    case ERR_HIERARCHY_CHANGE_NOT_IMPLEMENTED: os << "ERR_HIERARCHY_CHANGE_NOT_IMPLEMENTED"; break;
    case ERR_DELETE_METHOD_NOT_IMPLEMENTED: os << "ERR_DELETE_METHOD_NOT_IMPLEMENTED"; break;
    case ERR_UNSUPPORTED_VERSION: os << "ERR_UNSUPPORTED_VERSION"; break;
    case ERR_NAMES_DONT_MATCH: os << "ERR_NAMES_DONT_MATCH"; break;
    case ERR_CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED: os << "ERR_CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED"; break;
    case ERR_METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED: os << "ERR_METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED"; break;
    case ERR_NOT_IMPLEMENTED: os << "ERR_NOT_IMPLEMENTED"; break;
    case ERR_NULL_POINTER: os << "ERR_NULL_POINTER"; break;
    case ERR_ABSENT_INFORMATION: os << "ERR_ABSENT_INFORMATION"; break;
    case ERR_INVALID_EVENT_TYPE: os << "ERR_INVALID_EVENT_TYPE"; break;
    case ERR_ILLEGAL_ARGUMENT: os << "ERR_ILLEGAL_ARGUMENT"; break;
    case ERR_OUT_OF_MEMORY: os << "ERR_OUT_OF_MEMORY"; break;
    case ERR_ACCESS_DENIED: os << "ERR_ACCESS_DENIED"; break;
    case ERR_VM_DEAD: os << "ERR_VM_DEAD"; break;
    case ERR_INTERNAL: os << "ERR_INTERNAL"; break;
    case ERR_UNATTACHED_THREAD: os << "ERR_UNATTACHED_THREAD"; break;
    case ERR_INVALID_TAG: os << "ERR_INVALID_TAG"; break;
    case ERR_ALREADY_INVOKING: os << "ERR_ALREADY_INVOKING"; break;
    case ERR_INVALID_INDEX: os << "ERR_INVALID_INDEX"; break;
    case ERR_INVALID_LENGTH: os << "ERR_INVALID_LENGTH"; break;
    case ERR_INVALID_STRING: os << "ERR_INVALID_STRING"; break;
    case ERR_INVALID_CLASS_LOADER: os << "ERR_INVALID_CLASS_LOADER"; break;
    case ERR_INVALID_ARRAY: os << "ERR_INVALID_ARRAY"; break;
    case ERR_TRANSPORT_LOAD: os << "ERR_TRANSPORT_LOAD"; break;
    case ERR_TRANSPORT_INIT: os << "ERR_TRANSPORT_INIT"; break;
    case ERR_NATIVE_METHOD: os << "ERR_NATIVE_METHOD"; break;
    case ERR_INVALID_COUNT: os << "ERR_INVALID_COUNT"; break;
    default: os << "JdwpError[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpClassStatus& rhs) {
  switch (rhs) {
    case CS_VERIFIED: os << "CS_VERIFIED"; break;
    case CS_PREPARED: os << "CS_PREPARED"; break;
    case CS_INITIALIZED: os << "CS_INITIALIZED"; break;
    case CS_ERROR: os << "CS_ERROR"; break;
    default: os << "JdwpClassStatus[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const InvokeType& rhs) {
  switch (rhs) {
    case kStatic: os << "static"; break;
    case kDirect: os << "direct"; break;
    case kVirtual: os << "virtual"; break;
    case kSuper: os << "super"; break;
    case kInterface: os << "interface"; break;
    default: os << "InvokeType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const Instruction::Format& rhs) {
  switch (rhs) {
    case Instruction::k10x: os << "10x"; break;
    case Instruction::k12x: os << "12x"; break;
    case Instruction::k11n: os << "11n"; break;
    case Instruction::k11x: os << "11x"; break;
    case Instruction::k10t: os << "10t"; break;
    case Instruction::k20t: os << "20t"; break;
    case Instruction::k22x: os << "22x"; break;
    case Instruction::k21t: os << "21t"; break;
    case Instruction::k21s: os << "21s"; break;
    case Instruction::k21h: os << "21h"; break;
    case Instruction::k21c: os << "21c"; break;
    case Instruction::k23x: os << "23x"; break;
    case Instruction::k22b: os << "22b"; break;
    case Instruction::k22t: os << "22t"; break;
    case Instruction::k22s: os << "22s"; break;
    case Instruction::k22c: os << "22c"; break;
    case Instruction::k32x: os << "32x"; break;
    case Instruction::k30t: os << "30t"; break;
    case Instruction::k31t: os << "31t"; break;
    case Instruction::k31i: os << "31i"; break;
    case Instruction::k31c: os << "31c"; break;
    case Instruction::k35c: os << "35c"; break;
    case Instruction::k3rc: os << "3rc"; break;
    case Instruction::k51l: os << "51l"; break;
    default: os << "Instruction::Format[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace gc {
namespace space {
std::ostream& operator<<(std::ostream& os, const SpaceType& rhs) {
  switch (rhs) {
    case kSpaceTypeImageSpace: os << "SpaceTypeImageSpace"; break;
    case kSpaceTypeMallocSpace: os << "SpaceTypeMallocSpace"; break;
    case kSpaceTypeZygoteSpace: os << "SpaceTypeZygoteSpace"; break;
    case kSpaceTypeBumpPointerSpace: os << "SpaceTypeBumpPointerSpace"; break;
    case kSpaceTypeLargeObjectSpace: os << "SpaceTypeLargeObjectSpace"; break;
    default: os << "SpaceType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace space
}  // namespace gc
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
std::ostream& operator<<(std::ostream& os, const OatClassType& rhs) {
  switch (rhs) {
    case kOatClassAllCompiled: os << "OatClassAllCompiled"; break;
    case kOatClassSomeCompiled: os << "OatClassSomeCompiled"; break;
    case kOatClassNoneCompiled: os << "OatClassNoneCompiled"; break;
    case kOatClassMax: os << "OatClassMax"; break;
    default: os << "OatClassType[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace art

// This was automatically generated by /home/m/git/dex2oat/art/tools/generate_operator_out.py --- do not edit!
namespace art {
namespace JDWP {
std::ostream& operator<<(std::ostream& os, const JdwpTypeTag& rhs) {
  switch (rhs) {
    case TT_CLASS: os << "TT_CLASS"; break;
    case TT_INTERFACE: os << "TT_INTERFACE"; break;
    case TT_ARRAY: os << "TT_ARRAY"; break;
    default: os << "JdwpTypeTag[" << static_cast<int>(rhs) << "]"; break;
  }
  return os;
}
}  // namespace JDWP
}  // namespace art

